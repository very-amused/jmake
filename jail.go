package main

import (
	"fmt"
	"net/netip"
	"path"
	"strconv"
	"strings"
)

type JailConfig struct {
	// Jail name (extracted from toml key)
	Name string `toml:"-"`
	// Jail hostname (default: {Name}.{HostDomain}
	Hostname string
	// Jail ID (jid) (autogenerated)
	JID int `toml:"-"`

	// Unparsed Jail IP addresses (indexed by the bridge on which they'll be added)
	IP map[string]string

	// Parsed jail IP addresses
	IPs []JailIP `toml:"-"`

	ContextChecks

	zfs *ZFSconfig // ZFS config used for computing jail root path/dataset
}

// Parsed jail IP address
type JailIP struct {
	Bridge  string
	Addr    netip.Addr
	EpairNo int // Number to use when generating epair interfaces
}

// Path to jail root on host system
func (j *JailConfig) Path() string {
	return path.Join(j.zfs.Mountpoint, "containers", j.Name)
}

// Name of jail ZFS dataset
func (j *JailConfig) Dataset() string {
	return path.Join(j.zfs.Dataset, "containers", j.Name)
}

type JailConfigs map[string]*JailConfig

func (jc *JailConfigs) Generate(c *Config) (errs []error) {
	if c.ZFS == nil {
		return errs
	}

	jid := 1
	epairNo := 0
	for name, jail := range *jc {
		// Assign name + jid
		jail.Name = name
		jail.JID = jid
		jid++
		// Generat hostname from host domain if needed
		if jail.Hostname == "" {
			if c.Host == nil || c.Host.Domain == "" {
				errs = append(errs, fmt.Errorf("jail.%s: cannot generate jail hostname, missing [host.domain].", name))
			}
			jail.Hostname = jail.Name + "." + c.Host.Domain
		}

		// Validate IP addresses
		if err := jail.parseIPs(c.Bridge, &epairNo); err != nil {
			errs = append(errs, err)
		}

		// Attach ZFS config
		jail.zfs = c.ZFS
	}

	errs = append(errs, ExecTemplates(jc, JailConf)...)

	return errs
}

// Parse jail IP addresses
func (j *JailConfig) parseIPs(bridges *BridgeConfigs, epairNo *int) (err error) {
	// If no bridges are defined, we still want to show the below 'undefined bridge' error
	if bridges == nil {
		bridges = new(BridgeConfigs)
	}

	for bridgeName, ip := range j.IP {
		configStr := fmt.Sprintf("%s.ip.%s = %s", j.Name, bridgeName, ip)
		// Ignore and warn about IPs that don't attach to a defined bridge
		bridge, ok := (*bridges)[bridgeName]
		if !ok {
			return fmt.Errorf("jail IP is attached to an undefined bridge: %s", configStr)
		}

		// Parse the address and validate that it falls under the bridge's subnet
		var addr netip.Addr
		if addr, err = netip.ParseAddr(ip); err != nil {
			return err
		}
		if !bridge.NetworkPrefix.Contains(addr) {
			return fmt.Errorf("jail IP is outside bridge subnet: %s", configStr)
		}
		// Save parsed jail IP w/ a reserved epair number
		j.IPs = append(j.IPs, JailIP{Bridge: bridgeName, Addr: addr, EpairNo: *epairNo})
		*epairNo++
	}

	return nil
}

/*
	Get an IP's host identifier in a concatenated base 10 format w/ no separator chars.

This form is suitable for use in generating epair names: epair{hostID}{bridgeNo}.

WARNING: Beware edge cases when using prefixes larger than /24.
There are multiple ways to produce the same hostID for two IPs and get epair collisions.
- .25.0 and .0.250 both produce '250'
- .1.2 and .12 both produce '12'
*/
func hostID(ip netip.Addr, prefix netip.Prefix) string {
	mask := prefix.Masked().Addr().AsSlice()
	addr := ip.AsSlice()
	if len(mask) != len(addr) {
		return "" // ip protocol mismatch
	}

	var stem strings.Builder
	var i int
	for i = range addr {
		// Remove subnet prefix
		addr[i] &= ^mask[i]
		// Start the host ID at the first non-zero segment
		if addr[i] != 0 {
			break
		}
	}
	for _, a := range addr[i:] {
		stem.WriteString(strconv.FormatUint(uint64(a), 10))
	}

	return stem.String()
}
